<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en_US" xml:lang="en_US">
<!--
 * Created on Dec 17, 2008
 *
 * To change the template for this generated file go to
 * Window - Preferences - PHPeclipse - PHP - Code Templates
-->
 <head>
  <title>SANS parsers</title>
  <style type="text/css">
  	.line { font-size: 1px; border-bottom: thin solid; }
  	.timestamp { font-family: arial, helvetica, sans-serif; font-size: 75%; }
  	tt { font-family: monospace; }
  </style>
 </head>
 <body>
   <h1>SANS parsers</h1>
   <p>
     Callback-based STAR parsers similar to XML SAX.
   <p>
   <em>Project location:</em> <strong>svn file:///svn/sans</strong>
   <p>
     See also: <a href="/software/sans/">code documentation</a>.

   <h2>Description</h2>
   <p>
     Like SAX parsers, SANS parses input line-by-line and calls user-defined methods (callbacks) 
     for each element of NMR-STAR syntax (token) it encounters. The advantage is that usually parsing
     is very fast and requires very few resources, the disadvantage is that you have to write code
     to do anything with the tokens. (Unlike DOM-type parsers, e.g. starlib, that load the data in a
     tree-like data structure for you.)

   <h2>Implementations</h2>
   <p>
     As of this moment SANS parsers are implemented in Java, C++, and PHP (in <tt>java</tt>,
     <tt>c++</tt> and <tt>php</tt> subdirectories, resp). Each version is based on a scanner class:
     generated by flex/JFlex in C++ and Java versions, hand-written scanner using Perl-compatible
     regular expressions in PHP. There are several parser classes, e.g. mmCIF parser, validating
     NMR-STAR parser, NMR-STAR loop parser, etc. The parsers are hand-written: NMR-STAR/mmCIF syntax
     is fairly simple and hand-coding a parser is just as easy as writing a grammar specification
     file for a parser generator tool like yacc or cup.

   <h3>Callbacks</h3>
   <p>
     Callbacks are declared in two interfaces: <tt>ErrorHandler</tt> for error tokens, 
     <tt>ContentHandler</tt> for valid tokens. User code must implement those interfaces and pass
     the implementation class to parser's constructor. (In Java and PHP; in C++ interfaces are pure
     abstract classes and implementation class must be derived from them.)
   <p>
     Most callbacks are functions that return a boolean "stop" flag: if callback returns true, the
     parser stops. E.g. if you're extracting a few values from the top of a large file, you can quit
     as soon as you get the last one and not waste time parsing the remaining 100,000 lines. The 
     parser typically won't rewind or close the input stream, so parsing can be resumed later from
     wherever the file pointer happens to be at the time. (You can fast-forward the pointer, or rewind
     it using either parser's <tt>pushBack()</tt> method or stream's <tt>mark()</tt> and <tt>reset()</tt>
     methods before you call <tt>parse()</tt> again).
   <p>
     There are three <strong>error callbacks</strong>:<ol>
       <li>critical error is when the parser cannot continue, for example if NMR-STAR file does not
           start with a data block. This is a void function.</li>
       <li>a warning is generated e.g. when the parser encounters a keyword inside a value, for example
           "save_the_whales" in a semicolon-delimited value. The parse cannot tell whether it's a
           legitimate value, or a start of new saveframe that's inside the value because a closing
           delimiter is missing somewhere above.</li>
       <li>an error: depends on the parser and application.</li>
     </ol>
     For example, a loop count error would be an error when validating a BMRB entry. An application
     that's simply looking for a specific tag/value may not care at all about a loop count error someplace
     else in the file. (This is part of the reason why there are several different parsers in the package.)
     Errors returned by a parser are listed in the code documentation for the parser class.
   <p>
     There are two interfaces for <strong>content callbacks</strong>:<ol>
       <li>simple stupid one declares separate callbacks for tag and value, the parser calls them as it
           reads 'em. When parsing a loop it'll fire several <tt>tag()</tt> callbacks first, then a 
           bunch of <tt>value()</tt> callbacks. This is handy for putting values in a table-type
           storage: you get the list of columns first, then you can build up rows and insert those
           into data store.</li>
       <li>a smarter interface returns tag/value pair as a structure. This is more convenient when
           extracting a few values from the file, without storing the whole thing. Same callback is
           used for free and loop tags, tag/value data structure includes a boolean "in loop" flag.</li>
     </ol>
     <p>
     Some of the STAR tokens (dep. on the parser):
     <ul>
       <li>start of data block</li>
       <li>end of data block -- this is a "fake" token generated by the parser on EOF. 
           It's a void function</li>
       <li>start of a saveframe -- CIF/NMRIF parsers never call this and the next one</li>
       <li>end of a saveframe</li>
       <li>start of loop</li>
       <li>end of loop</li>
       <li>tag</li>
       <li>value</li>
    </ul>
   <div class="line">&nbsp;</div>

   <h2>Usage</h2>
   <p>
     Pick one of the <tt>ContentHandler</tt> interfaces and a parser the suits your
     requirements (see code documentation for details). Write a class that implements that
     interface, and <tt>ErrorHandler</tt> interface.
   <p>
     Java code to call the parser:
<pre>
    edu.bmrb.sans.STARLexer lex = new edu.bmrb.sans.STARLexer( in );
    Parser p = new Parser( lex, this, this );
    p.parse();
    in.close();
</pre>
     (where <tt>in</tt> is the input stream, <tt>Parser</tt> is the parser class of your
     choice, and <tt>this</tt> is your class that implements both handler interfaces).
   <p>
     If there is no suitable parser in this package, you can easily write your
     own using one of the existing ones as a template/starting point: STAR
     syntax is simple enough so a parser can be hand-written without much trouble.
     (If you roll your own parser, it probably belongs in your application, not in SANS package.)
   <p>
   <div class="line">&nbsp;</div>

   <p class="timestamp">
     Last updated: 2008-12-28
 </body>
</html>
